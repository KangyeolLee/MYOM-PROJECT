{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : global.draftjsToHtml = factory();\n})(this, function () {\n  'use strict';\n  /**\n  * Utility function to execute callback for eack key->value pair.\n  */\n\n  function forEach(obj, callback) {\n    if (obj) {\n      for (var key in obj) {\n        // eslint-disable-line no-restricted-syntax\n        if ({}.hasOwnProperty.call(obj, key)) {\n          callback(key, obj[key]);\n        }\n      }\n    }\n  }\n  /**\n  * The function returns true if the string passed to it has no content.\n  */\n\n\n  function isEmptyString(str) {\n    if (str === undefined || str === null || str.length === 0 || str.trim().length === 0) {\n      return true;\n    }\n\n    return false;\n  }\n  /**\n  * Mapping block-type to corresponding html tag.\n  */\n\n\n  var blockTypesMapping = {\n    unstyled: 'p',\n    'header-one': 'h1',\n    'header-two': 'h2',\n    'header-three': 'h3',\n    'header-four': 'h4',\n    'header-five': 'h5',\n    'header-six': 'h6',\n    'unordered-list-item': 'ul',\n    'ordered-list-item': 'ol',\n    blockquote: 'blockquote',\n    code: 'pre'\n  };\n  /**\n  * Function will return HTML tag for a block.\n  */\n\n  function getBlockTag(type) {\n    return type && blockTypesMapping[type];\n  }\n  /**\n  * Function will return style string for a block.\n  */\n\n\n  function getBlockStyle(data) {\n    var styles = '';\n    forEach(data, function (key, value) {\n      if (value) {\n        styles += key + ':' + value + ';';\n      }\n    });\n    return styles;\n  }\n  /**\n  * The function returns an array of hashtag-sections in blocks.\n  * These will be areas in block which have hashtags applicable to them.\n  */\n\n\n  function getHashtagRanges(blockText, hashtagConfig) {\n    var sections = [];\n\n    if (hashtagConfig) {\n      var counter = 0;\n      var startIndex = 0;\n      var text = blockText;\n      var trigger = hashtagConfig.trigger || '#';\n      var separator = hashtagConfig.separator || ' ';\n\n      for (; text.length > 0 && startIndex >= 0;) {\n        if (text[0] === trigger) {\n          startIndex = 0;\n          counter = 0;\n          text = text.substr(trigger.length);\n        } else {\n          startIndex = text.indexOf(separator + trigger);\n\n          if (startIndex >= 0) {\n            text = text.substr(startIndex + (separator + trigger).length);\n            counter += startIndex + separator.length;\n          }\n        }\n\n        if (startIndex >= 0) {\n          var endIndex = text.indexOf(separator) >= 0 ? text.indexOf(separator) : text.length;\n          var hashtag = text.substr(0, endIndex);\n\n          if (hashtag && hashtag.length > 0) {\n            sections.push({\n              offset: counter,\n              length: hashtag.length + trigger.length,\n              type: 'HASHTAG'\n            });\n          }\n\n          counter += trigger.length;\n        }\n      }\n    }\n\n    return sections;\n  }\n  /**\n  * The function returns an array of entity-sections in blocks.\n  * These will be areas in block which have same entity or no entity applicable to them.\n  */\n\n\n  function getSections(block, hashtagConfig) {\n    var sections = [];\n    var lastOffset = 0;\n    var sectionRanges = block.entityRanges.map(function (range) {\n      var offset = range.offset,\n          length = range.length,\n          key = range.key;\n      return {\n        offset: offset,\n        length: length,\n        key: key,\n        type: 'ENTITY'\n      };\n    });\n    sectionRanges = sectionRanges.concat(getHashtagRanges(block.text, hashtagConfig));\n    sectionRanges = sectionRanges.sort(function (s1, s2) {\n      return s1.offset - s2.offset;\n    });\n    sectionRanges.forEach(function (r) {\n      if (r.offset > lastOffset) {\n        sections.push({\n          start: lastOffset,\n          end: r.offset\n        });\n      }\n\n      sections.push({\n        start: r.offset,\n        end: r.offset + r.length,\n        entityKey: r.key,\n        type: r.type\n      });\n      lastOffset = r.offset + r.length;\n    });\n\n    if (lastOffset < block.text.length) {\n      sections.push({\n        start: lastOffset,\n        end: block.text.length\n      });\n    }\n\n    return sections;\n  }\n  /**\n  * Function to check if the block is an atomic entity block.\n  */\n\n\n  function isAtomicEntityBlock(block) {\n    if (block.entityRanges.length > 0 && (isEmptyString(block.text) || block.type === 'atomic')) {\n      return true;\n    }\n\n    return false;\n  }\n  /**\n  * The function will return array of inline styles applicable to the block.\n  */\n\n\n  function getStyleArrayForBlock(block) {\n    var text = block.text,\n        inlineStyleRanges = block.inlineStyleRanges;\n    var inlineStyles = {\n      BOLD: new Array(text.length),\n      ITALIC: new Array(text.length),\n      UNDERLINE: new Array(text.length),\n      STRIKETHROUGH: new Array(text.length),\n      CODE: new Array(text.length),\n      SUPERSCRIPT: new Array(text.length),\n      SUBSCRIPT: new Array(text.length),\n      COLOR: new Array(text.length),\n      BGCOLOR: new Array(text.length),\n      FONTSIZE: new Array(text.length),\n      FONTFAMILY: new Array(text.length),\n      length: text.length\n    };\n\n    if (inlineStyleRanges && inlineStyleRanges.length > 0) {\n      inlineStyleRanges.forEach(function (range) {\n        var offset = range.offset;\n        var length = offset + range.length;\n\n        for (var i = offset; i < length; i += 1) {\n          if (range.style.indexOf('color-') === 0) {\n            inlineStyles.COLOR[i] = range.style.substring(6);\n          } else if (range.style.indexOf('bgcolor-') === 0) {\n            inlineStyles.BGCOLOR[i] = range.style.substring(8);\n          } else if (range.style.indexOf('fontsize-') === 0) {\n            inlineStyles.FONTSIZE[i] = range.style.substring(9);\n          } else if (range.style.indexOf('fontfamily-') === 0) {\n            inlineStyles.FONTFAMILY[i] = range.style.substring(11);\n          } else if (inlineStyles[range.style]) {\n            inlineStyles[range.style][i] = true;\n          }\n        }\n      });\n    }\n\n    return inlineStyles;\n  }\n  /**\n  * The function will return inline style applicable at some offset within a block.\n  */\n\n\n  function getStylesAtOffset(inlineStyles, offset) {\n    var styles = {};\n\n    if (inlineStyles.COLOR[offset]) {\n      styles.COLOR = inlineStyles.COLOR[offset];\n    }\n\n    if (inlineStyles.BGCOLOR[offset]) {\n      styles.BGCOLOR = inlineStyles.BGCOLOR[offset];\n    }\n\n    if (inlineStyles.FONTSIZE[offset]) {\n      styles.FONTSIZE = inlineStyles.FONTSIZE[offset];\n    }\n\n    if (inlineStyles.FONTFAMILY[offset]) {\n      styles.FONTFAMILY = inlineStyles.FONTFAMILY[offset];\n    }\n\n    if (inlineStyles.UNDERLINE[offset]) {\n      styles.UNDERLINE = true;\n    }\n\n    if (inlineStyles.ITALIC[offset]) {\n      styles.ITALIC = true;\n    }\n\n    if (inlineStyles.BOLD[offset]) {\n      styles.BOLD = true;\n    }\n\n    if (inlineStyles.STRIKETHROUGH[offset]) {\n      styles.STRIKETHROUGH = true;\n    }\n\n    if (inlineStyles.CODE[offset]) {\n      styles.CODE = true;\n    }\n\n    if (inlineStyles.SUBSCRIPT[offset]) {\n      styles.SUBSCRIPT = true;\n    }\n\n    if (inlineStyles.SUPERSCRIPT[offset]) {\n      styles.SUPERSCRIPT = true;\n    }\n\n    return styles;\n  }\n  /**\n  * Function returns true for a set of styles if the value of these styles at an offset\n  * are same as that on the previous offset.\n  */\n\n\n  function sameStyleAsPrevious(inlineStyles, styles, index) {\n    var sameStyled = true;\n\n    if (index > 0 && index < inlineStyles.length) {\n      styles.forEach(function (style) {\n        sameStyled = sameStyled && inlineStyles[style][index] === inlineStyles[style][index - 1];\n      });\n    } else {\n      sameStyled = false;\n    }\n\n    return sameStyled;\n  }\n  /**\n  * Function returns html for text depending on inline style tags applicable to it.\n  */\n\n\n  function addInlineStyleMarkup(style, content) {\n    if (style === 'BOLD') {\n      return '<strong>' + content + '</strong>';\n    } else if (style === 'ITALIC') {\n      return '<em>' + content + '</em>';\n    } else if (style === 'UNDERLINE') {\n      return '<ins>' + content + '</ins>';\n    } else if (style === 'STRIKETHROUGH') {\n      return '<del>' + content + '</del>';\n    } else if (style === 'CODE') {\n      return '<code>' + content + '</code>';\n    } else if (style === 'SUPERSCRIPT') {\n      return '<sup>' + content + '</sup>';\n    } else if (style === 'SUBSCRIPT') {\n      return '<sub>' + content + '</sub>';\n    }\n\n    return content;\n  }\n  /**\n  * The function returns text for given section of block after doing required character replacements.\n  */\n\n\n  function getSectionText(text) {\n    if (text && text.length > 0) {\n      var chars = text.map(function (ch) {\n        switch (ch) {\n          case '\\n':\n            return '<br>';\n\n          case '&':\n            return '&amp;';\n\n          case '<':\n            return '&lt;';\n\n          case '>':\n            return '&gt;';\n\n          default:\n            return ch;\n        }\n      });\n      return chars.join('');\n    }\n\n    return '';\n  }\n  /**\n  * Function returns html for text depending on inline style tags applicable to it.\n  */\n\n\n  function addStylePropertyMarkup(styles, text) {\n    if (styles && (styles.COLOR || styles.BGCOLOR || styles.FONTSIZE || styles.FONTFAMILY)) {\n      var styleString = 'style=\"';\n\n      if (styles.COLOR) {\n        styleString += 'color: ' + styles.COLOR + ';';\n      }\n\n      if (styles.BGCOLOR) {\n        styleString += 'background-color: ' + styles.BGCOLOR + ';';\n      }\n\n      if (styles.FONTSIZE) {\n        styleString += 'font-size: ' + styles.FONTSIZE + (/^\\d+$/.test(styles.FONTSIZE) ? 'px' : '') + ';';\n      }\n\n      if (styles.FONTFAMILY) {\n        styleString += 'font-family: ' + styles.FONTFAMILY + ';';\n      }\n\n      styleString += '\"';\n      return '<span ' + styleString + '>' + text + '</span>';\n    }\n\n    return text;\n  }\n  /**\n  * Function will return markup for Entity.\n  */\n\n\n  function getEntityMarkup(entityMap, entityKey, text, customEntityTransform) {\n    var entity = entityMap[entityKey];\n\n    if (typeof customEntityTransform === 'function') {\n      var html = customEntityTransform(entity, text);\n\n      if (html) {\n        return html;\n      }\n    }\n\n    if (entity.type === 'MENTION') {\n      return '<a href=\"' + entity.data.url + '\" class=\"wysiwyg-mention\" data-mention data-value=\"' + entity.data.value + '\">' + text + '</a>';\n    }\n\n    if (entity.type === 'LINK') {\n      var targetOption = entity.data.targetOption || '_self';\n      return '<a href=\"' + entity.data.url + '\" target=\"' + targetOption + '\">' + text + '</a>';\n    }\n\n    if (entity.type === 'IMAGE') {\n      return '<img src=\"' + entity.data.src + '\" alt=\"' + entity.data.alt + '\" style=\"float:' + (entity.data.alignment || 'none') + ';height: ' + entity.data.height + ';width: ' + entity.data.width + '\"/>';\n    }\n\n    if (entity.type === 'EMBEDDED_LINK') {\n      return '<iframe width=\"' + entity.data.width + '\" height=\"' + entity.data.height + '\" src=\"' + entity.data.src + '\" frameBorder=\"0\"></iframe>';\n    }\n\n    return text;\n  }\n  /**\n  * For a given section in a block the function will return a further list of sections,\n  * with similar inline styles applicable to them.\n  */\n\n\n  function getInlineStyleSections(block, styles, start, end) {\n    var styleSections = [];\n    var text = block.text;\n\n    if (text.length > 0) {\n      var inlineStyles = getStyleArrayForBlock(block);\n      var section = void 0;\n\n      for (var i = start; i < end; i += 1) {\n        if (i !== start && sameStyleAsPrevious(inlineStyles, styles, i)) {\n          section.text.push(text[i]);\n          section.end = i + 1;\n        } else {\n          section = {\n            styles: getStylesAtOffset(inlineStyles, i),\n            text: [text[i]],\n            start: i,\n            end: i + 1\n          };\n          styleSections.push(section);\n        }\n      }\n    }\n\n    return styleSections;\n  }\n  /**\n  * Replace leading blank spaces by &nbsp;\n  */\n\n\n  function trimLeadingZeros(sectionText) {\n    if (sectionText) {\n      var replacedText = sectionText;\n\n      for (var i = 0; i < replacedText.length; i += 1) {\n        if (sectionText[i] === ' ') {\n          replacedText = replacedText.replace(' ', '&nbsp;');\n        } else {\n          break;\n        }\n      }\n\n      return replacedText;\n    }\n\n    return sectionText;\n  }\n  /**\n  * Replace trailing blank spaces by &nbsp;\n  */\n\n\n  function trimTrailingZeros(sectionText) {\n    if (sectionText) {\n      var replacedText = sectionText;\n\n      for (var i = replacedText.length - 1; i >= 0; i -= 1) {\n        if (replacedText[i] === ' ') {\n          replacedText = replacedText.substring(0, i) + '&nbsp;' + replacedText.substring(i + 1);\n        } else {\n          break;\n        }\n      }\n\n      return replacedText;\n    }\n\n    return sectionText;\n  }\n  /**\n  * The method returns markup for section to which inline styles\n  * like BOLD, ITALIC, UNDERLINE, STRIKETHROUGH, CODE, SUPERSCRIPT, SUBSCRIPT are applicable.\n  */\n\n\n  function getStyleTagSectionMarkup(styleSection) {\n    var styles = styleSection.styles,\n        text = styleSection.text;\n    var content = getSectionText(text);\n    forEach(styles, function (style, value) {\n      content = addInlineStyleMarkup(style, content, value);\n    });\n    return content;\n  }\n  /**\n  * The method returns markup for section to which inline styles\n  like color, background-color, font-size are applicable.\n  */\n\n\n  function getInlineStyleSectionMarkup(block, styleSection) {\n    var styleTagSections = getInlineStyleSections(block, ['BOLD', 'ITALIC', 'UNDERLINE', 'STRIKETHROUGH', 'CODE', 'SUPERSCRIPT', 'SUBSCRIPT'], styleSection.start, styleSection.end);\n    var styleSectionText = '';\n    styleTagSections.forEach(function (stylePropertySection) {\n      styleSectionText += getStyleTagSectionMarkup(stylePropertySection);\n    });\n    styleSectionText = addStylePropertyMarkup(styleSection.styles, styleSectionText);\n    return styleSectionText;\n  }\n  /*\n  * The method returns markup for an entity section.\n  * An entity section is a continuous section in a block\n  * to which same entity or no entity is applicable.\n  */\n\n\n  function getSectionMarkup(block, entityMap, section, customEntityTransform) {\n    var entityInlineMarkup = [];\n    var inlineStyleSections = getInlineStyleSections(block, ['COLOR', 'BGCOLOR', 'FONTSIZE', 'FONTFAMILY'], section.start, section.end);\n    inlineStyleSections.forEach(function (styleSection) {\n      entityInlineMarkup.push(getInlineStyleSectionMarkup(block, styleSection));\n    });\n    var sectionText = entityInlineMarkup.join('');\n\n    if (section.type === 'ENTITY') {\n      if (section.entityKey !== undefined && section.entityKey !== null) {\n        sectionText = getEntityMarkup(entityMap, section.entityKey, sectionText, customEntityTransform); // eslint-disable-line max-len\n      }\n    } else if (section.type === 'HASHTAG') {\n      sectionText = '<a href=\"' + sectionText + '\" class=\"wysiwyg-hashtag\">' + sectionText + '</a>';\n    }\n\n    return sectionText;\n  }\n  /**\n  * Function will return the markup for block preserving the inline styles and\n  * special characters like newlines or blank spaces.\n  */\n\n\n  function getBlockInnerMarkup(block, entityMap, hashtagConfig, customEntityTransform) {\n    var blockMarkup = [];\n    var sections = getSections(block, hashtagConfig);\n    sections.forEach(function (section, index) {\n      var sectionText = getSectionMarkup(block, entityMap, section, customEntityTransform);\n\n      if (index === 0) {\n        sectionText = trimLeadingZeros(sectionText);\n      }\n\n      if (index === sections.length - 1) {\n        sectionText = trimTrailingZeros(sectionText);\n      }\n\n      blockMarkup.push(sectionText);\n    });\n    return blockMarkup.join('');\n  }\n  /**\n  * Function will return html for the block.\n  */\n\n\n  function getBlockMarkup(block, entityMap, hashtagConfig, directional, customEntityTransform) {\n    var blockHtml = [];\n\n    if (isAtomicEntityBlock(block)) {\n      blockHtml.push(getEntityMarkup(entityMap, block.entityRanges[0].key, undefined, customEntityTransform));\n    } else {\n      var blockTag = getBlockTag(block.type);\n\n      if (blockTag) {\n        blockHtml.push('<' + blockTag);\n        var blockStyle = getBlockStyle(block.data);\n\n        if (blockStyle) {\n          blockHtml.push(' style=\"' + blockStyle + '\"');\n        }\n\n        if (directional) {\n          blockHtml.push(' dir = \"auto\"');\n        }\n\n        blockHtml.push('>');\n        blockHtml.push(getBlockInnerMarkup(block, entityMap, hashtagConfig, customEntityTransform));\n        blockHtml.push('</' + blockTag + '>');\n      }\n    }\n\n    blockHtml.push('\\n');\n    return blockHtml.join('');\n  }\n  /**\n  * Function to check if a block is of type list.\n  */\n\n\n  function isList(blockType) {\n    return blockType === 'unordered-list-item' || blockType === 'ordered-list-item';\n  }\n  /**\n  * Function will return html markup for a list block.\n  */\n\n\n  function getListMarkup(listBlocks, entityMap, hashtagConfig, directional, customEntityTransform) {\n    var listHtml = [];\n    var nestedListBlock = [];\n    var previousBlock = void 0;\n    listBlocks.forEach(function (block) {\n      var nestedBlock = false;\n\n      if (!previousBlock) {\n        listHtml.push('<' + getBlockTag(block.type) + '>\\n');\n      } else if (previousBlock.type !== block.type) {\n        listHtml.push('</' + getBlockTag(previousBlock.type) + '>\\n');\n        listHtml.push('<' + getBlockTag(block.type) + '>\\n');\n      } else if (previousBlock.depth === block.depth) {\n        if (nestedListBlock && nestedListBlock.length > 0) {\n          listHtml.push(getListMarkup(nestedListBlock, entityMap, hashtagConfig, directional, customEntityTransform));\n          nestedListBlock = [];\n        }\n      } else {\n        nestedBlock = true;\n        nestedListBlock.push(block);\n      }\n\n      if (!nestedBlock) {\n        listHtml.push('<li');\n        var blockStyle = getBlockStyle(block.data);\n\n        if (blockStyle) {\n          listHtml.push(' style=\"' + blockStyle + '\"');\n        }\n\n        if (directional) {\n          listHtml.push(' dir = \"auto\"');\n        }\n\n        listHtml.push('>');\n        listHtml.push(getBlockInnerMarkup(block, entityMap, hashtagConfig, customEntityTransform));\n        listHtml.push('</li>\\n');\n        previousBlock = block;\n      }\n    });\n\n    if (nestedListBlock && nestedListBlock.length > 0) {\n      listHtml.push(getListMarkup(nestedListBlock, entityMap, hashtagConfig, directional, customEntityTransform));\n    }\n\n    listHtml.push('</' + getBlockTag(previousBlock.type) + '>\\n');\n    return listHtml.join('');\n  }\n  /**\n  * The function will generate html markup for given draftjs editorContent.\n  */\n\n\n  function draftToHtml(editorContent, hashtagConfig, directional, customEntityTransform) {\n    var html = [];\n\n    if (editorContent) {\n      var blocks = editorContent.blocks,\n          entityMap = editorContent.entityMap;\n\n      if (blocks && blocks.length > 0) {\n        var listBlocks = [];\n        blocks.forEach(function (block) {\n          if (isList(block.type)) {\n            listBlocks.push(block);\n          } else {\n            if (listBlocks.length > 0) {\n              var listHtml = getListMarkup(listBlocks, entityMap, hashtagConfig, customEntityTransform); // eslint-disable-line max-len\n\n              html.push(listHtml);\n              listBlocks = [];\n            }\n\n            var blockHtml = getBlockMarkup(block, entityMap, hashtagConfig, directional, customEntityTransform);\n            html.push(blockHtml);\n          }\n        });\n\n        if (listBlocks.length > 0) {\n          var listHtml = getListMarkup(listBlocks, entityMap, hashtagConfig, directional, customEntityTransform); // eslint-disable-line max-len\n\n          html.push(listHtml);\n          listBlocks = [];\n        }\n      }\n    }\n\n    return html.join('');\n  }\n\n  return draftToHtml;\n});","map":{"version":3,"sources":["/Users/JeHongHwang/Desktop/leekang/node_modules/draftjs-to-html/lib/draftjs-to-html.js"],"names":["global","factory","exports","module","define","amd","draftjsToHtml","forEach","obj","callback","key","hasOwnProperty","call","isEmptyString","str","undefined","length","trim","blockTypesMapping","unstyled","blockquote","code","getBlockTag","type","getBlockStyle","data","styles","value","getHashtagRanges","blockText","hashtagConfig","sections","counter","startIndex","text","trigger","separator","substr","indexOf","endIndex","hashtag","push","offset","getSections","block","lastOffset","sectionRanges","entityRanges","map","range","concat","sort","s1","s2","r","start","end","entityKey","isAtomicEntityBlock","getStyleArrayForBlock","inlineStyleRanges","inlineStyles","BOLD","Array","ITALIC","UNDERLINE","STRIKETHROUGH","CODE","SUPERSCRIPT","SUBSCRIPT","COLOR","BGCOLOR","FONTSIZE","FONTFAMILY","i","style","substring","getStylesAtOffset","sameStyleAsPrevious","index","sameStyled","addInlineStyleMarkup","content","getSectionText","chars","ch","join","addStylePropertyMarkup","styleString","test","getEntityMarkup","entityMap","customEntityTransform","entity","html","url","targetOption","src","alt","alignment","height","width","getInlineStyleSections","styleSections","section","trimLeadingZeros","sectionText","replacedText","replace","trimTrailingZeros","getStyleTagSectionMarkup","styleSection","getInlineStyleSectionMarkup","styleTagSections","styleSectionText","stylePropertySection","getSectionMarkup","entityInlineMarkup","inlineStyleSections","getBlockInnerMarkup","blockMarkup","getBlockMarkup","directional","blockHtml","blockTag","blockStyle","isList","blockType","getListMarkup","listBlocks","listHtml","nestedListBlock","previousBlock","nestedBlock","depth","draftToHtml","editorContent","blocks"],"mappings":"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","sourcesContent":["(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n\ttypeof define === 'function' && define.amd ? define(factory) :\n\t(global.draftjsToHtml = factory());\n}(this, (function () { 'use strict';\n\n/**\n* Utility function to execute callback for eack key->value pair.\n*/\nfunction forEach(obj, callback) {\n  if (obj) {\n    for (var key in obj) {\n      // eslint-disable-line no-restricted-syntax\n      if ({}.hasOwnProperty.call(obj, key)) {\n        callback(key, obj[key]);\n      }\n    }\n  }\n}\n\n/**\n* The function returns true if the string passed to it has no content.\n*/\nfunction isEmptyString(str) {\n  if (str === undefined || str === null || str.length === 0 || str.trim().length === 0) {\n    return true;\n  }\n  return false;\n}\n\n/**\n* Mapping block-type to corresponding html tag.\n*/\nvar blockTypesMapping = {\n  unstyled: 'p',\n  'header-one': 'h1',\n  'header-two': 'h2',\n  'header-three': 'h3',\n  'header-four': 'h4',\n  'header-five': 'h5',\n  'header-six': 'h6',\n  'unordered-list-item': 'ul',\n  'ordered-list-item': 'ol',\n  blockquote: 'blockquote',\n  code: 'pre'\n};\n\n/**\n* Function will return HTML tag for a block.\n*/\nfunction getBlockTag(type) {\n  return type && blockTypesMapping[type];\n}\n\n/**\n* Function will return style string for a block.\n*/\nfunction getBlockStyle(data) {\n  var styles = '';\n  forEach(data, function (key, value) {\n    if (value) {\n      styles += key + ':' + value + ';';\n    }\n  });\n  return styles;\n}\n\n/**\n* The function returns an array of hashtag-sections in blocks.\n* These will be areas in block which have hashtags applicable to them.\n*/\nfunction getHashtagRanges(blockText, hashtagConfig) {\n  var sections = [];\n  if (hashtagConfig) {\n    var counter = 0;\n    var startIndex = 0;\n    var text = blockText;\n    var trigger = hashtagConfig.trigger || '#';\n    var separator = hashtagConfig.separator || ' ';\n    for (; text.length > 0 && startIndex >= 0;) {\n      if (text[0] === trigger) {\n        startIndex = 0;\n        counter = 0;\n        text = text.substr(trigger.length);\n      } else {\n        startIndex = text.indexOf(separator + trigger);\n        if (startIndex >= 0) {\n          text = text.substr(startIndex + (separator + trigger).length);\n          counter += startIndex + separator.length;\n        }\n      }\n      if (startIndex >= 0) {\n        var endIndex = text.indexOf(separator) >= 0 ? text.indexOf(separator) : text.length;\n        var hashtag = text.substr(0, endIndex);\n        if (hashtag && hashtag.length > 0) {\n          sections.push({\n            offset: counter,\n            length: hashtag.length + trigger.length,\n            type: 'HASHTAG'\n          });\n        }\n        counter += trigger.length;\n      }\n    }\n  }\n  return sections;\n}\n\n/**\n* The function returns an array of entity-sections in blocks.\n* These will be areas in block which have same entity or no entity applicable to them.\n*/\nfunction getSections(block, hashtagConfig) {\n  var sections = [];\n  var lastOffset = 0;\n  var sectionRanges = block.entityRanges.map(function (range) {\n    var offset = range.offset,\n        length = range.length,\n        key = range.key;\n\n    return {\n      offset: offset,\n      length: length,\n      key: key,\n      type: 'ENTITY'\n    };\n  });\n  sectionRanges = sectionRanges.concat(getHashtagRanges(block.text, hashtagConfig));\n  sectionRanges = sectionRanges.sort(function (s1, s2) {\n    return s1.offset - s2.offset;\n  });\n  sectionRanges.forEach(function (r) {\n    if (r.offset > lastOffset) {\n      sections.push({\n        start: lastOffset,\n        end: r.offset\n      });\n    }\n    sections.push({\n      start: r.offset,\n      end: r.offset + r.length,\n      entityKey: r.key,\n      type: r.type\n    });\n    lastOffset = r.offset + r.length;\n  });\n  if (lastOffset < block.text.length) {\n    sections.push({\n      start: lastOffset,\n      end: block.text.length\n    });\n  }\n  return sections;\n}\n\n/**\n* Function to check if the block is an atomic entity block.\n*/\nfunction isAtomicEntityBlock(block) {\n  if (block.entityRanges.length > 0 && (isEmptyString(block.text) || block.type === 'atomic')) {\n    return true;\n  }\n  return false;\n}\n\n/**\n* The function will return array of inline styles applicable to the block.\n*/\nfunction getStyleArrayForBlock(block) {\n  var text = block.text,\n      inlineStyleRanges = block.inlineStyleRanges;\n\n  var inlineStyles = {\n    BOLD: new Array(text.length),\n    ITALIC: new Array(text.length),\n    UNDERLINE: new Array(text.length),\n    STRIKETHROUGH: new Array(text.length),\n    CODE: new Array(text.length),\n    SUPERSCRIPT: new Array(text.length),\n    SUBSCRIPT: new Array(text.length),\n    COLOR: new Array(text.length),\n    BGCOLOR: new Array(text.length),\n    FONTSIZE: new Array(text.length),\n    FONTFAMILY: new Array(text.length),\n    length: text.length\n  };\n  if (inlineStyleRanges && inlineStyleRanges.length > 0) {\n    inlineStyleRanges.forEach(function (range) {\n      var offset = range.offset;\n\n      var length = offset + range.length;\n      for (var i = offset; i < length; i += 1) {\n        if (range.style.indexOf('color-') === 0) {\n          inlineStyles.COLOR[i] = range.style.substring(6);\n        } else if (range.style.indexOf('bgcolor-') === 0) {\n          inlineStyles.BGCOLOR[i] = range.style.substring(8);\n        } else if (range.style.indexOf('fontsize-') === 0) {\n          inlineStyles.FONTSIZE[i] = range.style.substring(9);\n        } else if (range.style.indexOf('fontfamily-') === 0) {\n          inlineStyles.FONTFAMILY[i] = range.style.substring(11);\n        } else if (inlineStyles[range.style]) {\n          inlineStyles[range.style][i] = true;\n        }\n      }\n    });\n  }\n  return inlineStyles;\n}\n\n/**\n* The function will return inline style applicable at some offset within a block.\n*/\nfunction getStylesAtOffset(inlineStyles, offset) {\n  var styles = {};\n  if (inlineStyles.COLOR[offset]) {\n    styles.COLOR = inlineStyles.COLOR[offset];\n  }\n  if (inlineStyles.BGCOLOR[offset]) {\n    styles.BGCOLOR = inlineStyles.BGCOLOR[offset];\n  }\n  if (inlineStyles.FONTSIZE[offset]) {\n    styles.FONTSIZE = inlineStyles.FONTSIZE[offset];\n  }\n  if (inlineStyles.FONTFAMILY[offset]) {\n    styles.FONTFAMILY = inlineStyles.FONTFAMILY[offset];\n  }\n  if (inlineStyles.UNDERLINE[offset]) {\n    styles.UNDERLINE = true;\n  }\n  if (inlineStyles.ITALIC[offset]) {\n    styles.ITALIC = true;\n  }\n  if (inlineStyles.BOLD[offset]) {\n    styles.BOLD = true;\n  }\n  if (inlineStyles.STRIKETHROUGH[offset]) {\n    styles.STRIKETHROUGH = true;\n  }\n  if (inlineStyles.CODE[offset]) {\n    styles.CODE = true;\n  }\n  if (inlineStyles.SUBSCRIPT[offset]) {\n    styles.SUBSCRIPT = true;\n  }\n  if (inlineStyles.SUPERSCRIPT[offset]) {\n    styles.SUPERSCRIPT = true;\n  }\n  return styles;\n}\n\n/**\n* Function returns true for a set of styles if the value of these styles at an offset\n* are same as that on the previous offset.\n*/\nfunction sameStyleAsPrevious(inlineStyles, styles, index) {\n  var sameStyled = true;\n  if (index > 0 && index < inlineStyles.length) {\n    styles.forEach(function (style) {\n      sameStyled = sameStyled && inlineStyles[style][index] === inlineStyles[style][index - 1];\n    });\n  } else {\n    sameStyled = false;\n  }\n  return sameStyled;\n}\n\n/**\n* Function returns html for text depending on inline style tags applicable to it.\n*/\nfunction addInlineStyleMarkup(style, content) {\n  if (style === 'BOLD') {\n    return '<strong>' + content + '</strong>';\n  } else if (style === 'ITALIC') {\n    return '<em>' + content + '</em>';\n  } else if (style === 'UNDERLINE') {\n    return '<ins>' + content + '</ins>';\n  } else if (style === 'STRIKETHROUGH') {\n    return '<del>' + content + '</del>';\n  } else if (style === 'CODE') {\n    return '<code>' + content + '</code>';\n  } else if (style === 'SUPERSCRIPT') {\n    return '<sup>' + content + '</sup>';\n  } else if (style === 'SUBSCRIPT') {\n    return '<sub>' + content + '</sub>';\n  }\n  return content;\n}\n\n/**\n* The function returns text for given section of block after doing required character replacements.\n*/\nfunction getSectionText(text) {\n  if (text && text.length > 0) {\n    var chars = text.map(function (ch) {\n      switch (ch) {\n        case '\\n':\n          return '<br>';\n        case '&':\n          return '&amp;';\n        case '<':\n          return '&lt;';\n        case '>':\n          return '&gt;';\n        default:\n          return ch;\n      }\n    });\n    return chars.join('');\n  }\n  return '';\n}\n\n/**\n* Function returns html for text depending on inline style tags applicable to it.\n*/\nfunction addStylePropertyMarkup(styles, text) {\n  if (styles && (styles.COLOR || styles.BGCOLOR || styles.FONTSIZE || styles.FONTFAMILY)) {\n    var styleString = 'style=\"';\n    if (styles.COLOR) {\n      styleString += 'color: ' + styles.COLOR + ';';\n    }\n    if (styles.BGCOLOR) {\n      styleString += 'background-color: ' + styles.BGCOLOR + ';';\n    }\n    if (styles.FONTSIZE) {\n      styleString += 'font-size: ' + styles.FONTSIZE + (/^\\d+$/.test(styles.FONTSIZE) ? 'px' : '') + ';';\n    }\n    if (styles.FONTFAMILY) {\n      styleString += 'font-family: ' + styles.FONTFAMILY + ';';\n    }\n    styleString += '\"';\n    return '<span ' + styleString + '>' + text + '</span>';\n  }\n  return text;\n}\n\n/**\n* Function will return markup for Entity.\n*/\nfunction getEntityMarkup(entityMap, entityKey, text, customEntityTransform) {\n  var entity = entityMap[entityKey];\n  if (typeof customEntityTransform === 'function') {\n    var html = customEntityTransform(entity, text);\n    if (html) {\n      return html;\n    }\n  }\n  if (entity.type === 'MENTION') {\n    return '<a href=\"' + entity.data.url + '\" class=\"wysiwyg-mention\" data-mention data-value=\"' + entity.data.value + '\">' + text + '</a>';\n  }\n  if (entity.type === 'LINK') {\n    var targetOption = entity.data.targetOption || '_self';\n    return '<a href=\"' + entity.data.url + '\" target=\"' + targetOption + '\">' + text + '</a>';\n  }\n  if (entity.type === 'IMAGE') {\n    return '<img src=\"' + entity.data.src + '\" alt=\"' + entity.data.alt + '\" style=\"float:' + (entity.data.alignment || 'none') + ';height: ' + entity.data.height + ';width: ' + entity.data.width + '\"/>';\n  }\n  if (entity.type === 'EMBEDDED_LINK') {\n    return '<iframe width=\"' + entity.data.width + '\" height=\"' + entity.data.height + '\" src=\"' + entity.data.src + '\" frameBorder=\"0\"></iframe>';\n  }\n  return text;\n}\n\n/**\n* For a given section in a block the function will return a further list of sections,\n* with similar inline styles applicable to them.\n*/\nfunction getInlineStyleSections(block, styles, start, end) {\n  var styleSections = [];\n  var text = block.text;\n\n  if (text.length > 0) {\n    var inlineStyles = getStyleArrayForBlock(block);\n    var section = void 0;\n    for (var i = start; i < end; i += 1) {\n      if (i !== start && sameStyleAsPrevious(inlineStyles, styles, i)) {\n        section.text.push(text[i]);\n        section.end = i + 1;\n      } else {\n        section = {\n          styles: getStylesAtOffset(inlineStyles, i),\n          text: [text[i]],\n          start: i,\n          end: i + 1\n        };\n        styleSections.push(section);\n      }\n    }\n  }\n  return styleSections;\n}\n\n/**\n* Replace leading blank spaces by &nbsp;\n*/\nfunction trimLeadingZeros(sectionText) {\n  if (sectionText) {\n    var replacedText = sectionText;\n    for (var i = 0; i < replacedText.length; i += 1) {\n      if (sectionText[i] === ' ') {\n        replacedText = replacedText.replace(' ', '&nbsp;');\n      } else {\n        break;\n      }\n    }\n    return replacedText;\n  }\n  return sectionText;\n}\n\n/**\n* Replace trailing blank spaces by &nbsp;\n*/\nfunction trimTrailingZeros(sectionText) {\n  if (sectionText) {\n    var replacedText = sectionText;\n    for (var i = replacedText.length - 1; i >= 0; i -= 1) {\n      if (replacedText[i] === ' ') {\n        replacedText = replacedText.substring(0, i) + '&nbsp;' + replacedText.substring(i + 1);\n      } else {\n        break;\n      }\n    }\n    return replacedText;\n  }\n  return sectionText;\n}\n\n/**\n* The method returns markup for section to which inline styles\n* like BOLD, ITALIC, UNDERLINE, STRIKETHROUGH, CODE, SUPERSCRIPT, SUBSCRIPT are applicable.\n*/\nfunction getStyleTagSectionMarkup(styleSection) {\n  var styles = styleSection.styles,\n      text = styleSection.text;\n\n  var content = getSectionText(text);\n  forEach(styles, function (style, value) {\n    content = addInlineStyleMarkup(style, content, value);\n  });\n  return content;\n}\n\n/**\n* The method returns markup for section to which inline styles\nlike color, background-color, font-size are applicable.\n*/\nfunction getInlineStyleSectionMarkup(block, styleSection) {\n  var styleTagSections = getInlineStyleSections(block, ['BOLD', 'ITALIC', 'UNDERLINE', 'STRIKETHROUGH', 'CODE', 'SUPERSCRIPT', 'SUBSCRIPT'], styleSection.start, styleSection.end);\n  var styleSectionText = '';\n  styleTagSections.forEach(function (stylePropertySection) {\n    styleSectionText += getStyleTagSectionMarkup(stylePropertySection);\n  });\n  styleSectionText = addStylePropertyMarkup(styleSection.styles, styleSectionText);\n  return styleSectionText;\n}\n\n/*\n* The method returns markup for an entity section.\n* An entity section is a continuous section in a block\n* to which same entity or no entity is applicable.\n*/\nfunction getSectionMarkup(block, entityMap, section, customEntityTransform) {\n  var entityInlineMarkup = [];\n  var inlineStyleSections = getInlineStyleSections(block, ['COLOR', 'BGCOLOR', 'FONTSIZE', 'FONTFAMILY'], section.start, section.end);\n  inlineStyleSections.forEach(function (styleSection) {\n    entityInlineMarkup.push(getInlineStyleSectionMarkup(block, styleSection));\n  });\n  var sectionText = entityInlineMarkup.join('');\n  if (section.type === 'ENTITY') {\n    if (section.entityKey !== undefined && section.entityKey !== null) {\n      sectionText = getEntityMarkup(entityMap, section.entityKey, sectionText, customEntityTransform); // eslint-disable-line max-len\n    }\n  } else if (section.type === 'HASHTAG') {\n    sectionText = '<a href=\"' + sectionText + '\" class=\"wysiwyg-hashtag\">' + sectionText + '</a>';\n  }\n  return sectionText;\n}\n\n/**\n* Function will return the markup for block preserving the inline styles and\n* special characters like newlines or blank spaces.\n*/\nfunction getBlockInnerMarkup(block, entityMap, hashtagConfig, customEntityTransform) {\n  var blockMarkup = [];\n  var sections = getSections(block, hashtagConfig);\n  sections.forEach(function (section, index) {\n    var sectionText = getSectionMarkup(block, entityMap, section, customEntityTransform);\n    if (index === 0) {\n      sectionText = trimLeadingZeros(sectionText);\n    }\n    if (index === sections.length - 1) {\n      sectionText = trimTrailingZeros(sectionText);\n    }\n    blockMarkup.push(sectionText);\n  });\n  return blockMarkup.join('');\n}\n\n/**\n* Function will return html for the block.\n*/\nfunction getBlockMarkup(block, entityMap, hashtagConfig, directional, customEntityTransform) {\n  var blockHtml = [];\n  if (isAtomicEntityBlock(block)) {\n    blockHtml.push(getEntityMarkup(entityMap, block.entityRanges[0].key, undefined, customEntityTransform));\n  } else {\n    var blockTag = getBlockTag(block.type);\n    if (blockTag) {\n      blockHtml.push('<' + blockTag);\n      var blockStyle = getBlockStyle(block.data);\n      if (blockStyle) {\n        blockHtml.push(' style=\"' + blockStyle + '\"');\n      }\n      if (directional) {\n        blockHtml.push(' dir = \"auto\"');\n      }\n      blockHtml.push('>');\n      blockHtml.push(getBlockInnerMarkup(block, entityMap, hashtagConfig, customEntityTransform));\n      blockHtml.push('</' + blockTag + '>');\n    }\n  }\n  blockHtml.push('\\n');\n  return blockHtml.join('');\n}\n\n/**\n* Function to check if a block is of type list.\n*/\nfunction isList(blockType) {\n  return blockType === 'unordered-list-item' || blockType === 'ordered-list-item';\n}\n\n/**\n* Function will return html markup for a list block.\n*/\nfunction getListMarkup(listBlocks, entityMap, hashtagConfig, directional, customEntityTransform) {\n  var listHtml = [];\n  var nestedListBlock = [];\n  var previousBlock = void 0;\n  listBlocks.forEach(function (block) {\n    var nestedBlock = false;\n    if (!previousBlock) {\n      listHtml.push('<' + getBlockTag(block.type) + '>\\n');\n    } else if (previousBlock.type !== block.type) {\n      listHtml.push('</' + getBlockTag(previousBlock.type) + '>\\n');\n      listHtml.push('<' + getBlockTag(block.type) + '>\\n');\n    } else if (previousBlock.depth === block.depth) {\n      if (nestedListBlock && nestedListBlock.length > 0) {\n        listHtml.push(getListMarkup(nestedListBlock, entityMap, hashtagConfig, directional, customEntityTransform));\n        nestedListBlock = [];\n      }\n    } else {\n      nestedBlock = true;\n      nestedListBlock.push(block);\n    }\n    if (!nestedBlock) {\n      listHtml.push('<li');\n      var blockStyle = getBlockStyle(block.data);\n      if (blockStyle) {\n        listHtml.push(' style=\"' + blockStyle + '\"');\n      }\n      if (directional) {\n        listHtml.push(' dir = \"auto\"');\n      }\n      listHtml.push('>');\n      listHtml.push(getBlockInnerMarkup(block, entityMap, hashtagConfig, customEntityTransform));\n      listHtml.push('</li>\\n');\n      previousBlock = block;\n    }\n  });\n  if (nestedListBlock && nestedListBlock.length > 0) {\n    listHtml.push(getListMarkup(nestedListBlock, entityMap, hashtagConfig, directional, customEntityTransform));\n  }\n  listHtml.push('</' + getBlockTag(previousBlock.type) + '>\\n');\n  return listHtml.join('');\n}\n\n/**\n* The function will generate html markup for given draftjs editorContent.\n*/\nfunction draftToHtml(editorContent, hashtagConfig, directional, customEntityTransform) {\n  var html = [];\n  if (editorContent) {\n    var blocks = editorContent.blocks,\n        entityMap = editorContent.entityMap;\n\n    if (blocks && blocks.length > 0) {\n      var listBlocks = [];\n      blocks.forEach(function (block) {\n        if (isList(block.type)) {\n          listBlocks.push(block);\n        } else {\n          if (listBlocks.length > 0) {\n            var listHtml = getListMarkup(listBlocks, entityMap, hashtagConfig, customEntityTransform); // eslint-disable-line max-len\n            html.push(listHtml);\n            listBlocks = [];\n          }\n          var blockHtml = getBlockMarkup(block, entityMap, hashtagConfig, directional, customEntityTransform);\n          html.push(blockHtml);\n        }\n      });\n      if (listBlocks.length > 0) {\n        var listHtml = getListMarkup(listBlocks, entityMap, hashtagConfig, directional, customEntityTransform); // eslint-disable-line max-len\n        html.push(listHtml);\n        listBlocks = [];\n      }\n    }\n  }\n  return html.join('');\n}\n\nreturn draftToHtml;\n\n})));\n"]},"metadata":{},"sourceType":"script"}