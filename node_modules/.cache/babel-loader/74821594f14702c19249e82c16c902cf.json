{"ast":null,"code":"function generatePatches(state, basepath, patches, inversePatches, baseValue, resultValue) {\n  if (patches) if (Array.isArray(baseValue)) generateArrayPatches(state, basepath, patches, inversePatches, baseValue, resultValue);else generateObjectPatches(state, basepath, patches, inversePatches, baseValue, resultValue);\n}\n\nfunction generateArrayPatches(state, basepath, patches, inversePatches, baseValue, resultValue) {\n  var shared = Math.min(baseValue.length, resultValue.length);\n\n  for (var i = 0; i < shared; i++) {\n    if (state.assigned[i] && baseValue[i] !== resultValue[i]) {\n      var path = basepath.concat(i);\n      patches.push({\n        op: \"replace\",\n        path: path,\n        value: resultValue[i]\n      });\n      inversePatches.push({\n        op: \"replace\",\n        path: path,\n        value: baseValue[i]\n      });\n    }\n  }\n\n  if (shared < resultValue.length) {\n    // stuff was added\n    for (var _i = shared; _i < resultValue.length; _i++) {\n      var _path = basepath.concat(_i);\n\n      patches.push({\n        op: \"add\",\n        path: _path,\n        value: resultValue[_i]\n      });\n    }\n\n    inversePatches.push({\n      op: \"replace\",\n      path: basepath.concat(\"length\"),\n      value: baseValue.length\n    });\n  } else if (shared < baseValue.length) {\n    // stuff was removed\n    patches.push({\n      op: \"replace\",\n      path: basepath.concat(\"length\"),\n      value: resultValue.length\n    });\n\n    for (var _i2 = shared; _i2 < baseValue.length; _i2++) {\n      var _path2 = basepath.concat(_i2);\n\n      inversePatches.push({\n        op: \"add\",\n        path: _path2,\n        value: baseValue[_i2]\n      });\n    }\n  }\n}\n\nfunction generateObjectPatches(state, basepath, patches, inversePatches, baseValue, resultValue) {\n  each(state.assigned, function (key, assignedValue) {\n    var origValue = baseValue[key];\n    var value = resultValue[key];\n    var op = !assignedValue ? \"remove\" : key in baseValue ? \"replace\" : \"add\";\n    if (origValue === baseValue && op === \"replace\") return;\n    var path = basepath.concat(key);\n    patches.push(op === \"remove\" ? {\n      op: op,\n      path: path\n    } : {\n      op: op,\n      path: path,\n      value: value\n    });\n    inversePatches.push(op === \"add\" ? {\n      op: \"remove\",\n      path: path\n    } : op === \"remove\" ? {\n      op: \"add\",\n      path: path,\n      value: origValue\n    } : {\n      op: \"replace\",\n      path: path,\n      value: origValue\n    });\n  });\n}\n\nfunction applyPatches(draft, patches) {\n  var _loop = function _loop(i) {\n    var patch = patches[i];\n\n    if (patch.path.length === 0 && patch.op === \"replace\") {\n      draft = patch.value;\n    } else {\n      var path = patch.path.slice();\n      var key = path.pop();\n      var base = path.reduce(function (current, part) {\n        if (!current) throw new Error(\"Cannot apply patch, path doesn't resolve: \" + patch.path.join(\"/\"));\n        return current[part];\n      }, draft);\n      if (!base) throw new Error(\"Cannot apply patch, path doesn't resolve: \" + patch.path.join(\"/\"));\n\n      switch (patch.op) {\n        case \"replace\":\n        case \"add\":\n          // TODO: add support is not extensive, it does not support insertion or `-` atm!\n          base[key] = patch.value;\n          break;\n\n        case \"remove\":\n          if (Array.isArray(base)) {\n            if (key === base.length - 1) base.length -= 1;else throw new Error(\"Remove can only remove the last key of an array, index: \" + key + \", length: \" + base.length);\n          } else delete base[key];\n\n          break;\n\n        default:\n          throw new Error(\"Unsupported patch operation: \" + patch.op);\n      }\n    }\n  };\n\n  for (var i = 0; i < patches.length; i++) {\n    _loop(i);\n  }\n\n  return draft;\n}\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar PROXY_STATE = typeof Symbol !== \"undefined\" ? Symbol(\"immer-proxy-state\") : \"__$immer_state\";\nvar RETURNED_AND_MODIFIED_ERROR = \"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\";\n\nfunction verifyMinified() {}\n\nvar inProduction = typeof process !== \"undefined\" && process.env.NODE_ENV === \"production\" || verifyMinified.name !== \"verifyMinified\";\nvar autoFreeze = !inProduction;\nvar useProxies = typeof Proxy !== \"undefined\";\n/**\n * Automatically freezes any state trees generated by immer.\n * This protects against accidental modifications of the state tree outside of an immer function.\n * This comes with a performance impact, so it is recommended to disable this option in production.\n * It is by default enabled.\n *\n * @returns {void}\n */\n\nfunction setAutoFreeze(enableAutoFreeze) {\n  autoFreeze = enableAutoFreeze;\n}\n\nfunction setUseProxies(value) {\n  useProxies = value;\n}\n\nfunction getUseProxies() {\n  return useProxies;\n}\n\nfunction isProxy(value) {\n  return !!value && !!value[PROXY_STATE];\n}\n\nfunction isProxyable(value) {\n  if (!value) return false;\n  if ((typeof value === \"undefined\" ? \"undefined\" : _typeof(value)) !== \"object\") return false;\n  if (Array.isArray(value)) return true;\n  var proto = Object.getPrototypeOf(value);\n  return proto === null || proto === Object.prototype;\n}\n\nfunction freeze(value) {\n  if (autoFreeze) {\n    Object.freeze(value);\n  }\n\n  return value;\n}\n\nvar assign = Object.assign || function assign(target, value) {\n  for (var key in value) {\n    if (has(value, key)) {\n      target[key] = value[key];\n    }\n  }\n\n  return target;\n};\n\nfunction shallowCopy(value) {\n  if (Array.isArray(value)) return value.slice();\n  var target = value.__proto__ === undefined ? Object.create(null) : {};\n  return assign(target, value);\n}\n\nfunction each(value, cb) {\n  if (Array.isArray(value)) {\n    for (var i = 0; i < value.length; i++) {\n      cb(i, value[i]);\n    }\n  } else {\n    for (var key in value) {\n      cb(key, value[key]);\n    }\n  }\n}\n\nfunction has(thing, prop) {\n  return Object.prototype.hasOwnProperty.call(thing, prop);\n} // given a base object, returns it if unmodified, or return the changed cloned if modified\n\n\nfunction finalize(base, path, patches, inversePatches) {\n  if (isProxy(base)) {\n    var state = base[PROXY_STATE];\n\n    if (state.modified === true) {\n      if (state.finalized === true) return state.copy;\n      state.finalized = true;\n      var result = finalizeObject(useProxies ? state.copy : state.copy = shallowCopy(base), state, path, patches, inversePatches);\n      generatePatches(state, path, patches, inversePatches, state.base, result);\n      return result;\n    } else {\n      return state.base;\n    }\n  }\n\n  finalizeNonProxiedObject(base);\n  return base;\n}\n\nfunction finalizeObject(copy, state, path, patches, inversePatches) {\n  var base = state.base;\n  each(copy, function (prop, value) {\n    if (value !== base[prop]) {\n      // if there was an assignment on this property, we don't need to generate\n      // patches for the subtree\n      var _generatePatches = patches && !has(state.assigned, prop);\n\n      copy[prop] = finalize(value, _generatePatches && path.concat(prop), _generatePatches && patches, inversePatches);\n    }\n  });\n  return freeze(copy);\n}\n\nfunction finalizeNonProxiedObject(parent) {\n  // If finalize is called on an object that was not a proxy, it means that it is an object that was not there in the original\n  // tree and it could contain proxies at arbitrarily places. Let's find and finalize them as well\n  if (!isProxyable(parent)) return;\n  if (Object.isFrozen(parent)) return;\n  each(parent, function (i, child) {\n    if (isProxy(child)) {\n      parent[i] = finalize(child);\n    } else finalizeNonProxiedObject(child);\n  }); // always freeze completely new data\n\n  freeze(parent);\n}\n\nfunction is(x, y) {\n  // From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n  if (x === y) {\n    return x !== 0 || 1 / x === 1 / y;\n  } else {\n    return x !== x && y !== y;\n  }\n} // @ts-check\n\n\nvar proxies = null;\nvar objectTraps = {\n  get: get$1,\n  has: function has$$1(target, prop) {\n    return prop in source(target);\n  },\n  ownKeys: function ownKeys(target) {\n    return Reflect.ownKeys(source(target));\n  },\n  set: set$1,\n  deleteProperty: deleteProperty,\n  getOwnPropertyDescriptor: getOwnPropertyDescriptor,\n  defineProperty: defineProperty$1,\n  setPrototypeOf: function setPrototypeOf() {\n    throw new Error(\"Immer does not support `setPrototypeOf()`.\");\n  }\n};\nvar arrayTraps = {};\neach(objectTraps, function (key, fn) {\n  arrayTraps[key] = function () {\n    arguments[0] = arguments[0][0];\n    return fn.apply(this, arguments);\n  };\n});\n\nfunction createState(parent, base) {\n  return {\n    modified: false,\n    // this tree is modified (either this object or one of it's children)\n    assigned: {},\n    // true: value was assigned to these props, false: was removed\n    finalized: false,\n    parent: parent,\n    base: base,\n    copy: undefined,\n    proxies: {}\n  };\n}\n\nfunction source(state) {\n  return state.modified === true ? state.copy : state.base;\n}\n\nfunction get$1(state, prop) {\n  if (prop === PROXY_STATE) return state;\n\n  if (state.modified) {\n    var value = state.copy[prop];\n    if (value === state.base[prop] && isProxyable(value)) // only create proxy if it is not yet a proxy, and not a new object\n      // (new objects don't need proxying, they will be processed in finalize anyway)\n      return state.copy[prop] = createProxy(state, value);\n    return value;\n  } else {\n    if (has(state.proxies, prop)) return state.proxies[prop];\n    var _value = state.base[prop];\n    if (!isProxy(_value) && isProxyable(_value)) return state.proxies[prop] = createProxy(state, _value);\n    return _value;\n  }\n}\n\nfunction set$1(state, prop, value) {\n  // TODO: optimize\n  state.assigned[prop] = true;\n\n  if (!state.modified) {\n    if (prop in state.base && is(state.base[prop], value) || has(state.proxies, prop) && state.proxies[prop] === value) return true;\n    markChanged(state);\n  }\n\n  state.copy[prop] = value;\n  return true;\n}\n\nfunction deleteProperty(state, prop) {\n  state.assigned[prop] = false;\n  markChanged(state);\n  delete state.copy[prop];\n  return true;\n}\n\nfunction getOwnPropertyDescriptor(state, prop) {\n  var owner = state.modified ? state.copy : has(state.proxies, prop) ? state.proxies : state.base;\n  var descriptor = Reflect.getOwnPropertyDescriptor(owner, prop);\n  if (descriptor && !(Array.isArray(owner) && prop === \"length\")) descriptor.configurable = true;\n  return descriptor;\n}\n\nfunction defineProperty$1() {\n  throw new Error(\"Immer does not support defining properties on draft objects.\");\n}\n\nfunction markChanged(state) {\n  if (!state.modified) {\n    state.modified = true;\n    state.copy = shallowCopy(state.base); // copy the proxies over the base-copy\n\n    Object.assign(state.copy, state.proxies); // yup that works for arrays as well\n\n    if (state.parent) markChanged(state.parent);\n  }\n} // creates a proxy for plain objects / arrays\n\n\nfunction createProxy(parentState, base, key) {\n  if (isProxy(base)) throw new Error(\"Immer bug. Plz report.\");\n  var state = createState(parentState, base, key);\n  var proxy = Array.isArray(base) ? Proxy.revocable([state], arrayTraps) : Proxy.revocable(state, objectTraps);\n  proxies.push(proxy);\n  return proxy.proxy;\n}\n\nfunction produceProxy(baseState, producer, patchListener) {\n  if (isProxy(baseState)) {\n    // See #100, don't nest producers\n    var returnValue = producer.call(baseState, baseState);\n    return returnValue === undefined ? baseState : returnValue;\n  }\n\n  var previousProxies = proxies;\n  proxies = [];\n  var patches = patchListener && [];\n  var inversePatches = patchListener && [];\n\n  try {\n    // create proxy for root\n    var rootProxy = createProxy(undefined, baseState); // execute the thunk\n\n    var _returnValue = producer.call(rootProxy, rootProxy); // and finalize the modified proxy\n\n\n    var result = void 0; // check whether the draft was modified and/or a value was returned\n\n    if (_returnValue !== undefined && _returnValue !== rootProxy) {\n      // something was returned, and it wasn't the proxy itself\n      if (rootProxy[PROXY_STATE].modified) throw new Error(RETURNED_AND_MODIFIED_ERROR); // See #117\n      // Should we just throw when returning a proxy which is not the root, but a subset of the original state?\n      // Looks like a wrongly modeled reducer\n\n      result = finalize(_returnValue);\n\n      if (patches) {\n        patches.push({\n          op: \"replace\",\n          path: [],\n          value: result\n        });\n        inversePatches.push({\n          op: \"replace\",\n          path: [],\n          value: baseState\n        });\n      }\n    } else {\n      result = finalize(rootProxy, [], patches, inversePatches);\n    } // revoke all proxies\n\n\n    each(proxies, function (_, p) {\n      return p.revoke();\n    });\n    patchListener && patchListener(patches, inversePatches);\n    return result;\n  } finally {\n    proxies = previousProxies;\n  }\n} // @ts-check\n\n\nvar descriptors = {};\nvar states = null;\n\nfunction createState$1(parent, proxy, base) {\n  return {\n    modified: false,\n    assigned: {},\n    // true: value was assigned to these props, false: was removed\n    hasCopy: false,\n    parent: parent,\n    base: base,\n    proxy: proxy,\n    copy: undefined,\n    finished: false,\n    finalizing: false,\n    finalized: false\n  };\n}\n\nfunction source$1(state) {\n  return state.hasCopy ? state.copy : state.base;\n}\n\nfunction _get(state, prop) {\n  assertUnfinished(state);\n  var value = source$1(state)[prop];\n\n  if (!state.finalizing && value === state.base[prop] && isProxyable(value)) {\n    // only create a proxy if the value is proxyable, and the value was in the base state\n    // if it wasn't in the base state, the object is already modified and we will process it in finalize\n    prepareCopy(state);\n    return state.copy[prop] = createProxy$1(state, value);\n  }\n\n  return value;\n}\n\nfunction _set(state, prop, value) {\n  assertUnfinished(state);\n  state.assigned[prop] = true; // optimization; skip this if there is no listener\n\n  if (!state.modified) {\n    if (is(source$1(state)[prop], value)) return;\n    markChanged$1(state);\n    prepareCopy(state);\n  }\n\n  state.copy[prop] = value;\n}\n\nfunction markChanged$1(state) {\n  if (!state.modified) {\n    state.modified = true;\n    if (state.parent) markChanged$1(state.parent);\n  }\n}\n\nfunction prepareCopy(state) {\n  if (state.hasCopy) return;\n  state.hasCopy = true;\n  state.copy = shallowCopy(state.base);\n} // creates a proxy for plain objects / arrays\n\n\nfunction createProxy$1(parent, base) {\n  var proxy = shallowCopy(base);\n  each(base, function (i) {\n    Object.defineProperty(proxy, \"\" + i, createPropertyProxy(\"\" + i));\n  });\n  var state = createState$1(parent, proxy, base);\n  createHiddenProperty(proxy, PROXY_STATE, state);\n  states.push(state);\n  return proxy;\n}\n\nfunction createPropertyProxy(prop) {\n  return descriptors[prop] || (descriptors[prop] = {\n    configurable: true,\n    enumerable: true,\n    get: function get$$1() {\n      return _get(this[PROXY_STATE], prop);\n    },\n    set: function set$$1(value) {\n      _set(this[PROXY_STATE], prop, value);\n    }\n  });\n}\n\nfunction assertUnfinished(state) {\n  if (state.finished === true) throw new Error(\"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" + JSON.stringify(state.copy || state.base));\n} // this sounds very expensive, but actually it is not that expensive in practice\n// as it will only visit proxies, and only do key-based change detection for objects for\n// which it is not already know that they are changed (that is, only object for which no known key was changed)\n\n\nfunction markChangesSweep() {\n  // intentionally we process the proxies in reverse order;\n  // ideally we start by processing leafs in the tree, because if a child has changed, we don't have to check the parent anymore\n  // reverse order of proxy creation approximates this\n  for (var i = states.length - 1; i >= 0; i--) {\n    var state = states[i];\n\n    if (state.modified === false) {\n      if (Array.isArray(state.base)) {\n        if (hasArrayChanges(state)) markChanged$1(state);\n      } else if (hasObjectChanges(state)) markChanged$1(state);\n    }\n  }\n}\n\nfunction markChangesRecursively(object) {\n  if (!object || (typeof object === \"undefined\" ? \"undefined\" : _typeof(object)) !== \"object\") return;\n  var state = object[PROXY_STATE];\n  if (!state) return;\n  var proxy = state.proxy,\n      base = state.base;\n\n  if (Array.isArray(object)) {\n    if (hasArrayChanges(state)) {\n      markChanged$1(state);\n      state.assigned.length = true;\n      if (proxy.length < base.length) for (var i = proxy.length; i < base.length; i++) {\n        state.assigned[i] = false;\n      } else for (var _i = base.length; _i < proxy.length; _i++) {\n        state.assigned[_i] = true;\n      }\n      each(proxy, function (index, child) {\n        if (!state.assigned[index]) markChangesRecursively(child);\n      });\n    }\n  } else {\n    var _diffKeys = diffKeys(base, proxy),\n        added = _diffKeys.added,\n        removed = _diffKeys.removed;\n\n    if (added.length > 0 || removed.length > 0) markChanged$1(state);\n    each(added, function (_, key) {\n      state.assigned[key] = true;\n    });\n    each(removed, function (_, key) {\n      state.assigned[key] = false;\n    });\n    each(proxy, function (key, child) {\n      if (!state.assigned[key]) markChangesRecursively(child);\n    });\n  }\n}\n\nfunction diffKeys(from, to) {\n  // TODO: optimize\n  var a = Object.keys(from);\n  var b = Object.keys(to);\n  return {\n    added: b.filter(function (key) {\n      return a.indexOf(key) === -1;\n    }),\n    removed: a.filter(function (key) {\n      return b.indexOf(key) === -1;\n    })\n  };\n}\n\nfunction hasObjectChanges(state) {\n  var baseKeys = Object.keys(state.base);\n  var keys = Object.keys(state.proxy);\n  return !shallowEqual(baseKeys, keys);\n}\n\nfunction hasArrayChanges(state) {\n  var proxy = state.proxy;\n  if (proxy.length !== state.base.length) return true; // See #116\n  // If we first shorten the length, our array interceptors will be removed.\n  // If after that new items are added, result in the same original length,\n  // those last items will have no intercepting property.\n  // So if there is no own descriptor on the last position, we know that items were removed and added\n  // N.B.: splice, unshift, etc only shift values around, but not prop descriptors, so we only have to check\n  // the last one\n\n  var descriptor = Object.getOwnPropertyDescriptor(proxy, proxy.length - 1); // descriptor can be null, but only for newly created sparse arrays, eg. new Array(10)\n\n  if (descriptor && !descriptor.get) return true; // For all other cases, we don't have to compare, as they would have been picked up by the index setters\n\n  return false;\n}\n\nfunction produceEs5(baseState, producer, patchListener) {\n  if (isProxy(baseState)) {\n    // See #100, don't nest producers\n    var returnValue = producer.call(baseState, baseState);\n    return returnValue === undefined ? baseState : returnValue;\n  }\n\n  var prevStates = states;\n  states = [];\n  var patches = patchListener && [];\n  var inversePatches = patchListener && [];\n\n  try {\n    // create proxy for root\n    var rootProxy = createProxy$1(undefined, baseState); // execute the thunk\n\n    var _returnValue = producer.call(rootProxy, rootProxy); // and finalize the modified proxy\n\n\n    each(states, function (_, state) {\n      state.finalizing = true;\n    });\n    var result = void 0; // check whether the draft was modified and/or a value was returned\n\n    if (_returnValue !== undefined && _returnValue !== rootProxy) {\n      // something was returned, and it wasn't the proxy itself\n      if (rootProxy[PROXY_STATE].modified) throw new Error(RETURNED_AND_MODIFIED_ERROR);\n      result = finalize(_returnValue);\n\n      if (patches) {\n        patches.push({\n          op: \"replace\",\n          path: [],\n          value: result\n        });\n        inversePatches.push({\n          op: \"replace\",\n          path: [],\n          value: baseState\n        });\n      }\n    } else {\n      if (patchListener) markChangesRecursively(rootProxy);\n      markChangesSweep(); // this one is more efficient if we don't need to know which attributes have changed\n\n      result = finalize(rootProxy, [], patches, inversePatches);\n    } // make sure all proxies become unusable\n\n\n    each(states, function (_, state) {\n      state.finished = true;\n    });\n    patchListener && patchListener(patches, inversePatches);\n    return result;\n  } finally {\n    states = prevStates;\n  }\n}\n\nfunction shallowEqual(objA, objB) {\n  //From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n  if (is(objA, objB)) return true;\n\n  if ((typeof objA === \"undefined\" ? \"undefined\" : _typeof(objA)) !== \"object\" || objA === null || (typeof objB === \"undefined\" ? \"undefined\" : _typeof(objB)) !== \"object\" || objB === null) {\n    return false;\n  }\n\n  var keysA = Object.keys(objA);\n  var keysB = Object.keys(objB);\n  if (keysA.length !== keysB.length) return false;\n\n  for (var i = 0; i < keysA.length; i++) {\n    if (!hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction createHiddenProperty(target, prop, value) {\n  Object.defineProperty(target, prop, {\n    value: value,\n    enumerable: false,\n    writable: true\n  });\n}\n/**\n * produce takes a state, and runs a function against it.\n * That function can freely mutate the state, as it will create copies-on-write.\n * This means that the original state will stay unchanged, and once the function finishes, the modified state is returned\n *\n * @export\n * @param {any} baseState - the state to start with\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n * @param {Function} patchListener - optional function that will be called with all the patches produces here\n * @returns {any} a new state, or the base state if nothing was modified\n */\n\n\nfunction produce(baseState, producer, patchListener) {\n  // prettier-ignore\n  if (arguments.length < 1 || arguments.length > 3) throw new Error(\"produce expects 1 to 3 arguments, got \" + arguments.length); // curried invocation\n\n  if (typeof baseState === \"function\") {\n    // prettier-ignore\n    if (typeof producer === \"function\") throw new Error(\"if first argument is a function (curried invocation), the second argument to produce cannot be a function\");\n    var initialState = producer;\n    var recipe = baseState;\n    return function () {\n      var args = arguments;\n      var currentState = args[0] === undefined && initialState !== undefined ? initialState : args[0];\n      return produce(currentState, function (draft) {\n        args[0] = draft; // blegh!\n\n        return recipe.apply(draft, args);\n      });\n    };\n  } // prettier-ignore\n\n\n  {\n    if (typeof producer !== \"function\") throw new Error(\"if first argument is not a function, the second argument to produce should be a function\");\n    if (patchListener !== undefined && typeof patchListener !== \"function\") throw new Error(\"the third argument of a producer should not be set or a function\");\n  } // if state is a primitive, don't bother proxying at all\n\n  if ((typeof baseState === \"undefined\" ? \"undefined\" : _typeof(baseState)) !== \"object\" || baseState === null) {\n    var returnValue = producer(baseState);\n    return returnValue === undefined ? baseState : returnValue;\n  }\n\n  if (!isProxyable(baseState)) throw new Error(\"the first argument to an immer producer should be a primitive, plain object or array, got \" + (typeof baseState === \"undefined\" ? \"undefined\" : _typeof(baseState)) + \": \\\"\" + baseState + \"\\\"\");\n  return getUseProxies() ? produceProxy(baseState, producer, patchListener) : produceEs5(baseState, producer, patchListener);\n}\n\nvar applyPatches$1 = produce(applyPatches);\nexport { produce, applyPatches$1 as applyPatches, setAutoFreeze, setUseProxies };\nexport default produce;","map":{"version":3,"sources":["../src/patches.js","../src/common.js","../src/proxy.js","../src/es5.js","../src/immer.js"],"names":["Array","generateArrayPatches","generateObjectPatches","shared","Math","baseValue","resultValue","i","state","path","basepath","op","value","length","origValue","key","patches","patch","base","current","PROXY_STATE","Symbol","RETURNED_AND_MODIFIED_ERROR","inProduction","process","verifyMinified","autoFreeze","useProxies","proto","Object","assign","has","target","isProxy","result","finalizeObject","shallowCopy","generatePatches","finalize","freeze","isProxyable","finalizeNonProxiedObject","x","y","proxies","objectTraps","prop","source","Reflect","arrayTraps","each","arguments","fn","createProxy","is","owner","descriptor","markChanged","createState","proxy","Proxy","returnValue","producer","previousProxies","patchListener","inversePatches","rootProxy","p","descriptors","states","createPropertyProxy","get","JSON","hasArrayChanges","hasObjectChanges","object","markChangesRecursively","added","removed","diffKeys","a","b","baseKeys","keys","shallowEqual","prevStates","objA","objB","keysA","keysB","hasOwnProperty","initialState","recipe","args","currentState","baseState","getUseProxies","produceProxy","produceEs5","applyPatches","produce"],"mappings":"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","sourcesContent":["import {each} from \"./common\"\n\nexport function generatePatches(\n    state,\n    basepath,\n    patches,\n    inversePatches,\n    baseValue,\n    resultValue\n) {\n    if (patches)\n        if (Array.isArray(baseValue))\n            generateArrayPatches(\n                state,\n                basepath,\n                patches,\n                inversePatches,\n                baseValue,\n                resultValue\n            )\n        else\n            generateObjectPatches(\n                state,\n                basepath,\n                patches,\n                inversePatches,\n                baseValue,\n                resultValue\n            )\n}\n\nexport function generateArrayPatches(\n    state,\n    basepath,\n    patches,\n    inversePatches,\n    baseValue,\n    resultValue\n) {\n    const shared = Math.min(baseValue.length, resultValue.length)\n    for (let i = 0; i < shared; i++) {\n        if (state.assigned[i] && baseValue[i] !== resultValue[i]) {\n            const path = basepath.concat(i)\n            patches.push({op: \"replace\", path, value: resultValue[i]})\n            inversePatches.push({op: \"replace\", path, value: baseValue[i]})\n        }\n    }\n    if (shared < resultValue.length) {\n        // stuff was added\n        for (let i = shared; i < resultValue.length; i++) {\n            const path = basepath.concat(i)\n            patches.push({op: \"add\", path, value: resultValue[i]})\n        }\n        inversePatches.push({\n            op: \"replace\",\n            path: basepath.concat(\"length\"),\n            value: baseValue.length\n        })\n    } else if (shared < baseValue.length) {\n        // stuff was removed\n        patches.push({\n            op: \"replace\",\n            path: basepath.concat(\"length\"),\n            value: resultValue.length\n        })\n        for (let i = shared; i < baseValue.length; i++) {\n            const path = basepath.concat(i)\n            inversePatches.push({op: \"add\", path, value: baseValue[i]})\n        }\n    }\n}\n\nfunction generateObjectPatches(\n    state,\n    basepath,\n    patches,\n    inversePatches,\n    baseValue,\n    resultValue\n) {\n    each(state.assigned, (key, assignedValue) => {\n        const origValue = baseValue[key]\n        const value = resultValue[key]\n        const op = !assignedValue\n            ? \"remove\"\n            : key in baseValue ? \"replace\" : \"add\"\n        if (origValue === baseValue && op === \"replace\") return\n        const path = basepath.concat(key)\n        patches.push(op === \"remove\" ? {op, path} : {op, path, value})\n        inversePatches.push(\n            op === \"add\"\n                ? {op: \"remove\", path}\n                : op === \"remove\"\n                  ? {op: \"add\", path, value: origValue}\n                  : {op: \"replace\", path, value: origValue}\n        )\n    })\n}\n\nexport function applyPatches(draft, patches) {\n    for (let i = 0; i < patches.length; i++) {\n        const patch = patches[i]\n        if (patch.path.length === 0 && patch.op === \"replace\") {\n            draft = patch.value\n        } else {\n            const path = patch.path.slice()\n            const key = path.pop()\n            const base = path.reduce((current, part) => {\n                if (!current)\n                    throw new Error(\n                        \"Cannot apply patch, path doesn't resolve: \" +\n                            patch.path.join(\"/\")\n                    )\n                return current[part]\n            }, draft)\n            if (!base)\n                throw new Error(\n                    \"Cannot apply patch, path doesn't resolve: \" +\n                        patch.path.join(\"/\")\n                )\n            switch (patch.op) {\n                case \"replace\":\n                case \"add\":\n                    // TODO: add support is not extensive, it does not support insertion or `-` atm!\n                    base[key] = patch.value\n                    break\n                case \"remove\":\n                    if (Array.isArray(base)) {\n                        if (key === base.length - 1) base.length -= 1\n                        else\n                            throw new Error(\n                                `Remove can only remove the last key of an array, index: ${key}, length: ${\n                                    base.length\n                                }`\n                            )\n                    } else delete base[key]\n                    break\n                default:\n                    throw new Error(\"Unsupported patch operation: \" + patch.op)\n            }\n        }\n    }\n    return draft\n}\n","import {generatePatches} from \"./patches\"\n\nexport const PROXY_STATE =\n    typeof Symbol !== \"undefined\"\n        ? Symbol(\"immer-proxy-state\")\n        : \"__$immer_state\"\n\nexport const RETURNED_AND_MODIFIED_ERROR =\n    \"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\"\n\nfunction verifyMinified() {}\n\nconst inProduction =\n    (typeof process !== \"undefined\" && process.env.NODE_ENV === \"production\") ||\n    verifyMinified.name !== \"verifyMinified\"\n\nlet autoFreeze = !inProduction\nlet useProxies = typeof Proxy !== \"undefined\"\n\n/**\n * Automatically freezes any state trees generated by immer.\n * This protects against accidental modifications of the state tree outside of an immer function.\n * This comes with a performance impact, so it is recommended to disable this option in production.\n * It is by default enabled.\n *\n * @returns {void}\n */\nexport function setAutoFreeze(enableAutoFreeze) {\n    autoFreeze = enableAutoFreeze\n}\n\nexport function setUseProxies(value) {\n    useProxies = value\n}\n\nexport function getUseProxies() {\n    return useProxies\n}\n\nexport function isProxy(value) {\n    return !!value && !!value[PROXY_STATE]\n}\n\nexport function isProxyable(value) {\n    if (!value) return false\n    if (typeof value !== \"object\") return false\n    if (Array.isArray(value)) return true\n    const proto = Object.getPrototypeOf(value)\n    return proto === null || proto === Object.prototype\n}\n\nexport function freeze(value) {\n    if (autoFreeze) {\n        Object.freeze(value)\n    }\n    return value\n}\n\nconst assign =\n    Object.assign ||\n    function assign(target, value) {\n        for (let key in value) {\n            if (has(value, key)) {\n                target[key] = value[key]\n            }\n        }\n        return target\n    }\n\nexport function shallowCopy(value) {\n    if (Array.isArray(value)) return value.slice()\n    const target = value.__proto__ === undefined ? Object.create(null) : {}\n    return assign(target, value)\n}\n\nexport function each(value, cb) {\n    if (Array.isArray(value)) {\n        for (let i = 0; i < value.length; i++) cb(i, value[i])\n    } else {\n        for (let key in value) cb(key, value[key])\n    }\n}\n\nexport function has(thing, prop) {\n    return Object.prototype.hasOwnProperty.call(thing, prop)\n}\n\n// given a base object, returns it if unmodified, or return the changed cloned if modified\nexport function finalize(base, path, patches, inversePatches) {\n    if (isProxy(base)) {\n        const state = base[PROXY_STATE]\n        if (state.modified === true) {\n            if (state.finalized === true) return state.copy\n            state.finalized = true\n            const result = finalizeObject(\n                useProxies ? state.copy : (state.copy = shallowCopy(base)),\n                state,\n                path,\n                patches,\n                inversePatches\n            )\n            generatePatches(\n                state,\n                path,\n                patches,\n                inversePatches,\n                state.base,\n                result\n            )\n            return result\n        } else {\n            return state.base\n        }\n    }\n    finalizeNonProxiedObject(base)\n    return base\n}\n\nfunction finalizeObject(copy, state, path, patches, inversePatches) {\n    const base = state.base\n    each(copy, (prop, value) => {\n        if (value !== base[prop]) {\n            // if there was an assignment on this property, we don't need to generate\n            // patches for the subtree\n            const generatePatches = patches && !has(state.assigned, prop)\n            copy[prop] = finalize(\n                value,\n                generatePatches && path.concat(prop),\n                generatePatches && patches,\n                inversePatches\n            )\n        }\n    })\n    return freeze(copy)\n}\n\nfunction finalizeNonProxiedObject(parent) {\n    // If finalize is called on an object that was not a proxy, it means that it is an object that was not there in the original\n    // tree and it could contain proxies at arbitrarily places. Let's find and finalize them as well\n    if (!isProxyable(parent)) return\n    if (Object.isFrozen(parent)) return\n    each(parent, (i, child) => {\n        if (isProxy(child)) {\n            parent[i] = finalize(child)\n        } else finalizeNonProxiedObject(child)\n    })\n    // always freeze completely new data\n    freeze(parent)\n}\n\nexport function verifyReturnValue(returnedValue, proxy, isProxyModified) {\n    if (returnedValue !== undefined && returnedValue !== proxy) {\n        // something was returned, and it wasn't the proxy itself\n        if (isProxyModified)\n            throw new Error(\n                \"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\"\n            )\n    }\n}\n\nexport function is(x, y) {\n    // From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n    if (x === y) {\n        return x !== 0 || 1 / x === 1 / y\n    } else {\n        return x !== x && y !== y\n    }\n}\n","\"use strict\"\n// @ts-check\n\nimport {\n    is,\n    has,\n    isProxyable,\n    isProxy,\n    PROXY_STATE,\n    finalize,\n    shallowCopy,\n    RETURNED_AND_MODIFIED_ERROR,\n    each\n} from \"./common\"\n\nlet proxies = null\n\nconst objectTraps = {\n    get,\n    has(target, prop) {\n        return prop in source(target)\n    },\n    ownKeys(target) {\n        return Reflect.ownKeys(source(target))\n    },\n    set,\n    deleteProperty,\n    getOwnPropertyDescriptor,\n    defineProperty,\n    setPrototypeOf() {\n        throw new Error(\"Immer does not support `setPrototypeOf()`.\")\n    }\n}\n\nconst arrayTraps = {}\neach(objectTraps, (key, fn) => {\n    arrayTraps[key] = function() {\n        arguments[0] = arguments[0][0]\n        return fn.apply(this, arguments)\n    }\n})\n\nfunction createState(parent, base) {\n    return {\n        modified: false, // this tree is modified (either this object or one of it's children)\n        assigned: {}, // true: value was assigned to these props, false: was removed\n        finalized: false,\n        parent,\n        base,\n        copy: undefined,\n        proxies: {}\n    }\n}\n\nfunction source(state) {\n    return state.modified === true ? state.copy : state.base\n}\n\nfunction get(state, prop) {\n    if (prop === PROXY_STATE) return state\n    if (state.modified) {\n        const value = state.copy[prop]\n        if (value === state.base[prop] && isProxyable(value))\n            // only create proxy if it is not yet a proxy, and not a new object\n            // (new objects don't need proxying, they will be processed in finalize anyway)\n            return (state.copy[prop] = createProxy(state, value))\n        return value\n    } else {\n        if (has(state.proxies, prop)) return state.proxies[prop]\n        const value = state.base[prop]\n        if (!isProxy(value) && isProxyable(value))\n            return (state.proxies[prop] = createProxy(state, value))\n        return value\n    }\n}\n\nfunction set(state, prop, value) {\n    // TODO: optimize\n    state.assigned[prop] = true\n    if (!state.modified) {\n        if (\n            (prop in state.base && is(state.base[prop], value)) ||\n            (has(state.proxies, prop) && state.proxies[prop] === value)\n        )\n            return true\n        markChanged(state)\n    }\n    state.copy[prop] = value\n    return true\n}\n\nfunction deleteProperty(state, prop) {\n    state.assigned[prop] = false\n    markChanged(state)\n    delete state.copy[prop]\n    return true\n}\n\nfunction getOwnPropertyDescriptor(state, prop) {\n    const owner = state.modified\n        ? state.copy\n        : has(state.proxies, prop) ? state.proxies : state.base\n    const descriptor = Reflect.getOwnPropertyDescriptor(owner, prop)\n    if (descriptor && !(Array.isArray(owner) && prop === \"length\"))\n        descriptor.configurable = true\n    return descriptor\n}\n\nfunction defineProperty() {\n    throw new Error(\n        \"Immer does not support defining properties on draft objects.\"\n    )\n}\n\nfunction markChanged(state) {\n    if (!state.modified) {\n        state.modified = true\n        state.copy = shallowCopy(state.base)\n        // copy the proxies over the base-copy\n        Object.assign(state.copy, state.proxies) // yup that works for arrays as well\n        if (state.parent) markChanged(state.parent)\n    }\n}\n\n// creates a proxy for plain objects / arrays\nfunction createProxy(parentState, base, key) {\n    if (isProxy(base)) throw new Error(\"Immer bug. Plz report.\")\n    const state = createState(parentState, base, key)\n    const proxy = Array.isArray(base)\n        ? Proxy.revocable([state], arrayTraps)\n        : Proxy.revocable(state, objectTraps)\n    proxies.push(proxy)\n    return proxy.proxy\n}\n\nexport function produceProxy(baseState, producer, patchListener) {\n    if (isProxy(baseState)) {\n        // See #100, don't nest producers\n        const returnValue = producer.call(baseState, baseState)\n        return returnValue === undefined ? baseState : returnValue\n    }\n    const previousProxies = proxies\n    proxies = []\n    const patches = patchListener && []\n    const inversePatches = patchListener && []\n    try {\n        // create proxy for root\n        const rootProxy = createProxy(undefined, baseState)\n        // execute the thunk\n        const returnValue = producer.call(rootProxy, rootProxy)\n        // and finalize the modified proxy\n        let result\n        // check whether the draft was modified and/or a value was returned\n        if (returnValue !== undefined && returnValue !== rootProxy) {\n            // something was returned, and it wasn't the proxy itself\n            if (rootProxy[PROXY_STATE].modified)\n                throw new Error(RETURNED_AND_MODIFIED_ERROR)\n\n            // See #117\n            // Should we just throw when returning a proxy which is not the root, but a subset of the original state?\n            // Looks like a wrongly modeled reducer\n            result = finalize(returnValue)\n            if (patches) {\n                patches.push({op: \"replace\", path: [], value: result})\n                inversePatches.push({op: \"replace\", path: [], value: baseState})\n            }\n        } else {\n            result = finalize(rootProxy, [], patches, inversePatches)\n        }\n        // revoke all proxies\n        each(proxies, (_, p) => p.revoke())\n        patchListener && patchListener(patches, inversePatches)\n        return result\n    } finally {\n        proxies = previousProxies\n    }\n}\n","\"use strict\"\n// @ts-check\n\nimport {\n    is,\n    isProxyable,\n    isProxy,\n    PROXY_STATE,\n    shallowCopy,\n    RETURNED_AND_MODIFIED_ERROR,\n    each,\n    finalize\n} from \"./common\"\n\nconst descriptors = {}\nlet states = null\n\nfunction createState(parent, proxy, base) {\n    return {\n        modified: false,\n        assigned: {}, // true: value was assigned to these props, false: was removed\n        hasCopy: false,\n        parent,\n        base,\n        proxy,\n        copy: undefined,\n        finished: false,\n        finalizing: false,\n        finalized: false\n    }\n}\n\nfunction source(state) {\n    return state.hasCopy ? state.copy : state.base\n}\n\nfunction get(state, prop) {\n    assertUnfinished(state)\n    const value = source(state)[prop]\n    if (!state.finalizing && value === state.base[prop] && isProxyable(value)) {\n        // only create a proxy if the value is proxyable, and the value was in the base state\n        // if it wasn't in the base state, the object is already modified and we will process it in finalize\n        prepareCopy(state)\n        return (state.copy[prop] = createProxy(state, value))\n    }\n    return value\n}\n\nfunction set(state, prop, value) {\n    assertUnfinished(state)\n    state.assigned[prop] = true // optimization; skip this if there is no listener\n    if (!state.modified) {\n        if (is(source(state)[prop], value)) return\n        markChanged(state)\n        prepareCopy(state)\n    }\n    state.copy[prop] = value\n}\n\nfunction markChanged(state) {\n    if (!state.modified) {\n        state.modified = true\n        if (state.parent) markChanged(state.parent)\n    }\n}\n\nfunction prepareCopy(state) {\n    if (state.hasCopy) return\n    state.hasCopy = true\n    state.copy = shallowCopy(state.base)\n}\n\n// creates a proxy for plain objects / arrays\nfunction createProxy(parent, base) {\n    const proxy = shallowCopy(base)\n    each(base, i => {\n        Object.defineProperty(proxy, \"\" + i, createPropertyProxy(\"\" + i))\n    })\n    const state = createState(parent, proxy, base)\n    createHiddenProperty(proxy, PROXY_STATE, state)\n    states.push(state)\n    return proxy\n}\n\nfunction createPropertyProxy(prop) {\n    return (\n        descriptors[prop] ||\n        (descriptors[prop] = {\n            configurable: true,\n            enumerable: true,\n            get() {\n                return get(this[PROXY_STATE], prop)\n            },\n            set(value) {\n                set(this[PROXY_STATE], prop, value)\n            }\n        })\n    )\n}\n\nfunction assertUnfinished(state) {\n    if (state.finished === true)\n        throw new Error(\n            \"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" +\n                JSON.stringify(state.copy || state.base)\n        )\n}\n\n// this sounds very expensive, but actually it is not that expensive in practice\n// as it will only visit proxies, and only do key-based change detection for objects for\n// which it is not already know that they are changed (that is, only object for which no known key was changed)\nfunction markChangesSweep() {\n    // intentionally we process the proxies in reverse order;\n    // ideally we start by processing leafs in the tree, because if a child has changed, we don't have to check the parent anymore\n    // reverse order of proxy creation approximates this\n    for (let i = states.length - 1; i >= 0; i--) {\n        const state = states[i]\n        if (state.modified === false) {\n            if (Array.isArray(state.base)) {\n                if (hasArrayChanges(state)) markChanged(state)\n            } else if (hasObjectChanges(state)) markChanged(state)\n        }\n    }\n}\n\nfunction markChangesRecursively(object) {\n    if (!object || typeof object !== \"object\") return\n    const state = object[PROXY_STATE]\n    if (!state) return\n    const {proxy, base} = state\n    if (Array.isArray(object)) {\n        if (hasArrayChanges(state)) {\n            markChanged(state)\n            state.assigned.length = true\n            if (proxy.length < base.length)\n                for (let i = proxy.length; i < base.length; i++)\n                    state.assigned[i] = false\n            else\n                for (let i = base.length; i < proxy.length; i++)\n                    state.assigned[i] = true\n            each(proxy, (index, child) => {\n                if (!state.assigned[index]) markChangesRecursively(child)\n            })\n        }\n    } else {\n        const {added, removed} = diffKeys(base, proxy)\n        if (added.length > 0 || removed.length > 0) markChanged(state)\n        each(added, (_, key) => {\n            state.assigned[key] = true\n        })\n        each(removed, (_, key) => {\n            state.assigned[key] = false\n        })\n        each(proxy, (key, child) => {\n            if (!state.assigned[key]) markChangesRecursively(child)\n        })\n    }\n}\n\nfunction diffKeys(from, to) {\n    // TODO: optimize\n    const a = Object.keys(from)\n    const b = Object.keys(to)\n    return {\n        added: b.filter(key => a.indexOf(key) === -1),\n        removed: a.filter(key => b.indexOf(key) === -1)\n    }\n}\n\nfunction hasObjectChanges(state) {\n    const baseKeys = Object.keys(state.base)\n    const keys = Object.keys(state.proxy)\n    return !shallowEqual(baseKeys, keys)\n}\n\nfunction hasArrayChanges(state) {\n    const {proxy} = state\n    if (proxy.length !== state.base.length) return true\n    // See #116\n    // If we first shorten the length, our array interceptors will be removed.\n    // If after that new items are added, result in the same original length,\n    // those last items will have no intercepting property.\n    // So if there is no own descriptor on the last position, we know that items were removed and added\n    // N.B.: splice, unshift, etc only shift values around, but not prop descriptors, so we only have to check\n    // the last one\n    const descriptor = Object.getOwnPropertyDescriptor(proxy, proxy.length - 1)\n    // descriptor can be null, but only for newly created sparse arrays, eg. new Array(10)\n    if (descriptor && !descriptor.get) return true\n    // For all other cases, we don't have to compare, as they would have been picked up by the index setters\n    return false\n}\n\nexport function produceEs5(baseState, producer, patchListener) {\n    if (isProxy(baseState)) {\n        // See #100, don't nest producers\n        const returnValue = producer.call(baseState, baseState)\n        return returnValue === undefined ? baseState : returnValue\n    }\n    const prevStates = states\n    states = []\n    const patches = patchListener && []\n    const inversePatches = patchListener && []\n    try {\n        // create proxy for root\n        const rootProxy = createProxy(undefined, baseState)\n        // execute the thunk\n        const returnValue = producer.call(rootProxy, rootProxy)\n        // and finalize the modified proxy\n        each(states, (_, state) => {\n            state.finalizing = true\n        })\n        let result\n        // check whether the draft was modified and/or a value was returned\n        if (returnValue !== undefined && returnValue !== rootProxy) {\n            // something was returned, and it wasn't the proxy itself\n            if (rootProxy[PROXY_STATE].modified)\n                throw new Error(RETURNED_AND_MODIFIED_ERROR)\n            result = finalize(returnValue)\n            if (patches) {\n                patches.push({op: \"replace\", path: [], value: result})\n                inversePatches.push({op: \"replace\", path: [], value: baseState})\n            }\n        } else {\n            if (patchListener) markChangesRecursively(rootProxy)\n            markChangesSweep() // this one is more efficient if we don't need to know which attributes have changed\n            result = finalize(rootProxy, [], patches, inversePatches)\n        }\n        // make sure all proxies become unusable\n        each(states, (_, state) => {\n            state.finished = true\n        })\n        patchListener && patchListener(patches, inversePatches)\n        return result\n    } finally {\n        states = prevStates\n    }\n}\n\nfunction shallowEqual(objA, objB) {\n    //From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n    if (is(objA, objB)) return true\n    if (\n        typeof objA !== \"object\" ||\n        objA === null ||\n        typeof objB !== \"object\" ||\n        objB === null\n    ) {\n        return false\n    }\n    const keysA = Object.keys(objA)\n    const keysB = Object.keys(objB)\n    if (keysA.length !== keysB.length) return false\n    for (let i = 0; i < keysA.length; i++) {\n        if (\n            !hasOwnProperty.call(objB, keysA[i]) ||\n            !is(objA[keysA[i]], objB[keysA[i]])\n        ) {\n            return false\n        }\n    }\n    return true\n}\n\nfunction createHiddenProperty(target, prop, value) {\n    Object.defineProperty(target, prop, {\n        value: value,\n        enumerable: false,\n        writable: true\n    })\n}\n","export {setAutoFreeze, setUseProxies} from \"./common\"\n\nimport {applyPatches as applyPatchesImpl} from \"./patches\"\nimport {isProxyable, getUseProxies} from \"./common\"\nimport {produceProxy} from \"./proxy\"\nimport {produceEs5} from \"./es5\"\n\n/**\n * produce takes a state, and runs a function against it.\n * That function can freely mutate the state, as it will create copies-on-write.\n * This means that the original state will stay unchanged, and once the function finishes, the modified state is returned\n *\n * @export\n * @param {any} baseState - the state to start with\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n * @param {Function} patchListener - optional function that will be called with all the patches produces here\n * @returns {any} a new state, or the base state if nothing was modified\n */\nexport function produce(baseState, producer, patchListener) {\n    // prettier-ignore\n    if (arguments.length < 1 || arguments.length > 3) throw new Error(\"produce expects 1 to 3 arguments, got \" + arguments.length)\n\n    // curried invocation\n    if (typeof baseState === \"function\") {\n        // prettier-ignore\n        if (typeof producer === \"function\") throw new Error(\"if first argument is a function (curried invocation), the second argument to produce cannot be a function\")\n\n        const initialState = producer\n        const recipe = baseState\n\n        return function() {\n            const args = arguments\n\n            const currentState =\n                args[0] === undefined && initialState !== undefined\n                    ? initialState\n                    : args[0]\n\n            return produce(currentState, draft => {\n                args[0] = draft // blegh!\n                return recipe.apply(draft, args)\n            })\n        }\n    }\n\n    // prettier-ignore\n    {\n        if (typeof producer !== \"function\") throw new Error(\"if first argument is not a function, the second argument to produce should be a function\")\n        if (patchListener !== undefined && typeof patchListener !== \"function\") throw new Error(\"the third argument of a producer should not be set or a function\")\n    }\n\n    // if state is a primitive, don't bother proxying at all\n    if (typeof baseState !== \"object\" || baseState === null) {\n        const returnValue = producer(baseState)\n        return returnValue === undefined ? baseState : returnValue\n    }\n\n    if (!isProxyable(baseState))\n        throw new Error(\n            `the first argument to an immer producer should be a primitive, plain object or array, got ${typeof baseState}: \"${baseState}\"`\n        )\n    return getUseProxies()\n        ? produceProxy(baseState, producer, patchListener)\n        : produceEs5(baseState, producer, patchListener)\n}\n\nexport default produce\n\nexport const applyPatches = produce(applyPatchesImpl)\n"]},"metadata":{},"sourceType":"module"}